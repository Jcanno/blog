(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{379:function(t,e,v){"use strict";v.r(e);var _=v(42),n=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"http-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-2"}},[t._v("#")]),t._v(" HTTP/2")]),t._v(" "),v("p",[t._v("HTTP/2 特点主要在改进性能")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("头部压缩")]),t._v(" "),v("p",[t._v("HTTP/1 中使用"),v("code",[t._v("Content-Encoding")]),t._v(" 来压缩 Body，但忽视了请求报文另一个重要部分：头部。请求头部往往会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，多达几百字节甚至上千字节。因此 HTTP/2 使用专门的“"),v("code",[t._v("HPACK")]),t._v("”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。")])]),t._v(" "),v("li",[v("p",[t._v("二进制格式")]),t._v(" "),v("p",[t._v("HTTP/2 向"),v("code",[t._v("TCP/IP")]),t._v("协议靠拢，使用二进制表示请求报文，加快了计算机的解析")])]),t._v(" "),v("li",[v("p",[t._v("多路复用")]),t._v(" "),v("p",[t._v("HTTP/2 将消息“碎片化”，并附上唯一的 ID，并发发送碎片化信息，到达目的地后会被重新组装成请求报文和消息，这就解决了 HTTP/1 中"),v("code",[t._v("队头阻塞")]),t._v("的问题")]),t._v(" "),v("p",[t._v("HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为“服务器推送”（Server Push，也叫 Cache Push）")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);